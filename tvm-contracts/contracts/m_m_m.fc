#include "imports/stdlib.fc";
#include "imports/errors.fc";
#include "imports/op_codes.fc";

global int g::total_stable;     ;; 
global int g::total_borrow_mmm; ;; 
global slice g::usdt_wallet; 
global slice g::owner;          ;; contract owner

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if ( in_msg_body.slice_empty?() ) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if ( flags & 1 ) { ;; ignore all bounced messages
        return ();
    }

    slice msg_sender = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    g::query_id = in_msg_body~load_uint(64);

    load_globals();

    if (op == op::deposit) {
        int amount = in_msg_body~load_uint(64);
        slice stablecoin = in_msg_body~load_msg_addr();
        
        deposit(amount, stablecoin, msg_sender);
        return store_globals();
    }
    if (op == op::withdraw) {

    }
    if (op == op::add_profit) {

    }
    throw(error::unknown_op);
}

() deposit(int amount, slice stablecoin, slice user) impure {
    require(amount > 0, error::invalid_amount);

    int mmm_amount;

    if (equal_slices(stablecoin, g::usdt_wallet)) {
        mmm_amount = (amount * g::total_borrow_mmm) / g::total_stable;
        g::total_stable += amount;
    } else {
        int ton_value = get_balance();
        require(ton_value >= amount, error::insufficient_ton);
        mmm_amount = (ton_value * g::total_borrow_mmm) / g::total_stable;
        g::total_stable += ton_value;
    }

    g::total_borrow_mmm += mmm_amount;

    store_globals();
}


int get_price() method_id {
    load_globals();
    require(g::total_borrow_mmm > 0, error::no_mmm_issued);
    ;; int value = totalStable * 10 ** 18) / totalBorrowMMM;
    return (g::total_stable * 1_000_000_000_000_000_000) / g::total_borrow_mmm;
}